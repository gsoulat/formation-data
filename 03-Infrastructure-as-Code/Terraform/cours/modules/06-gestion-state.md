# Module 6 : Gestion du State

> **Dur√©e : 45 minutes**
>
> Ma√Ætrisez la gestion du state Terraform pour la production

---

## üéØ Objectifs d'Apprentissage

√Ä la fin de ce module, vous serez capable de :

- ‚úÖ Comprendre le r√¥le du state file en profondeur
- ‚úÖ Configurer un backend distant (Azure Storage, AWS S3, Terraform Cloud)
- ‚úÖ Activer le state locking pour √©viter les conflits
- ‚úÖ Utiliser les commandes `terraform state` avanc√©es
- ‚úÖ Migrer d'un backend local vers un backend distant
- ‚úÖ S√©curiser le state file
- ‚úÖ G√©rer le state en √©quipe

---

## üìä Comprendre le State File

### Qu'est-ce que le State ?

Le **state file** (`terraform.tfstate`) est un fichier JSON qui contient :

- **Mapping** entre votre code Terraform et les ressources r√©elles
- **Attributs** de chaque ressource (IDs, IPs, configurations)
- **M√©tadonn√©es** (version Terraform, d√©pendances, etc.)
- **Outputs** calcul√©s

### Exemple de State File

```json
{
  "version": 4,
  "terraform_version": "1.6.6",
  "serial": 5,
  "lineage": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "outputs": {
    "resource_group_name": {
      "value": "rg-prod",
      "type": "string"
    }
  },
  "resources": [
    {
      "mode": "managed",
      "type": "azurerm_resource_group",
      "name": "main",
      "provider": "provider[\"registry.terraform.io/hashicorp/azurerm\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "/subscriptions/xxx/resourceGroups/rg-prod",
            "location": "westeurope",
            "name": "rg-prod",
            "tags": {
              "Environment": "Production"
            }
          },
          "dependencies": []
        }
      ]
    }
  ]
}
```

### R√¥les du State File

1. **Mapping Code ‚Üî Infrastructure**
   ```
   Code Terraform         State File           Infrastructure R√©elle
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   resource "..." {  ‚Üê‚Üí  "id": "/sub/.."  ‚Üê‚Üí  Resource Group Azure
   ```

2. **Performance** : Cache des attributs pour √©viter des appels API √† chaque `plan`

3. **D√©pendances** : Track les relations entre ressources

4. **Collaboration** : Permet √† plusieurs personnes de travailler ensemble

---

## üè† State Local vs Remote

### State Local (Par D√©faut)

**Avantages :**
- ‚úÖ Simple √† mettre en place
- ‚úÖ Pas de configuration suppl√©mentaire
- ‚úÖ Id√©al pour apprendre et tester

**Inconv√©nients :**
- ‚ùå Pas de collaboration possible
- ‚ùå Pas de sauvegarde automatique
- ‚ùå Risque de perte de donn√©es
- ‚ùå Pas de verrouillage (state locking)
- ‚ùå Secrets en clair dans le state

**Utilisation :**
```bash
# Par d√©faut, le state est stock√© localement
terraform init
terraform apply
# Cr√©e : terraform.tfstate
```

### State Remote (Production)

**Avantages :**
- ‚úÖ Collaboration en √©quipe
- ‚úÖ Sauvegarde automatique
- ‚úÖ State locking (√©vite les conflits)
- ‚úÖ Chiffrement des donn√©es
- ‚úÖ Versioning du state
- ‚úÖ Acc√®s contr√¥l√©

**Backends Populaires :**
- **Azure Storage** (azurerm)
- **AWS S3** (s3)
- **Terraform Cloud** (cloud)
- **Google Cloud Storage** (gcs)
- **HashiCorp Consul** (consul)

---

## ‚òÅÔ∏è Configuration d'un Backend Distant

### Backend Azure Storage

#### √âtape 1 : Cr√©er les Ressources Azure pour le Backend

```bash
# Variables
RESOURCE_GROUP_NAME="rg-terraform-state"
STORAGE_ACCOUNT_NAME="sttfstate$(date +%s)"
CONTAINER_NAME="tfstate"
LOCATION="West Europe"

# Cr√©er le Resource Group
az group create \
  --name $RESOURCE_GROUP_NAME \
  --location "$LOCATION"

# Cr√©er le Storage Account
az storage account create \
  --name $STORAGE_ACCOUNT_NAME \
  --resource-group $RESOURCE_GROUP_NAME \
  --location "$LOCATION" \
  --sku Standard_LRS \
  --encryption-services blob \
  --allow-blob-public-access false

# Cr√©er le Container
az storage container create \
  --name $CONTAINER_NAME \
  --account-name $STORAGE_ACCOUNT_NAME \
  --auth-mode login

# R√©cup√©rer la cl√© d'acc√®s
ACCOUNT_KEY=$(az storage account keys list \
  --resource-group $RESOURCE_GROUP_NAME \
  --account-name $STORAGE_ACCOUNT_NAME \
  --query '[0].value' -o tsv)

echo "Storage Account: $STORAGE_ACCOUNT_NAME"
echo "Container: $CONTAINER_NAME"
echo "Account Key: $ACCOUNT_KEY"
```

#### √âtape 2 : Configurer le Backend dans Terraform

```hcl
# backend.tf
terraform {
  backend "azurerm" {
    resource_group_name  = "rg-terraform-state"
    storage_account_name = "sttfstate1234567890"
    container_name       = "tfstate"
    key                  = "prod.terraform.tfstate"  # Nom du fichier state
  }
}
```

**Ou avec variables d'environnement (Recommand√© pour CI/CD) :**

```bash
export ARM_ACCESS_KEY="xxxxx"
```

```hcl
# backend.tf (sans les credentials)
terraform {
  backend "azurerm" {
    resource_group_name  = "rg-terraform-state"
    storage_account_name = "sttfstate1234567890"
    container_name       = "tfstate"
    key                  = "prod.terraform.tfstate"
  }
}
```

#### √âtape 3 : Initialiser avec le Backend

```bash
terraform init
```

**Sortie attendue :**

```
Initializing the backend...

Successfully configured the backend "azurerm"! Terraform will automatically
use this backend unless the backend configuration changes.
```

### Backend AWS S3

#### √âtape 1 : Cr√©er les Ressources AWS

```bash
# Variables
BUCKET_NAME="my-terraform-state-$(date +%s)"
REGION="eu-west-1"

# Cr√©er le bucket S3
aws s3api create-bucket \
  --bucket $BUCKET_NAME \
  --region $REGION \
  --create-bucket-configuration LocationConstraint=$REGION

# Activer le versioning
aws s3api put-bucket-versioning \
  --bucket $BUCKET_NAME \
  --versioning-configuration Status=Enabled

# Activer le chiffrement
aws s3api put-bucket-encryption \
  --bucket $BUCKET_NAME \
  --server-side-encryption-configuration '{
    "Rules": [{
      "ApplyServerSideEncryptionByDefault": {
        "SSEAlgorithm": "AES256"
      }
    }]
  }'

# Bloquer l'acc√®s public
aws s3api put-public-access-block \
  --bucket $BUCKET_NAME \
  --public-access-block-configuration \
    BlockPublicAcls=true,\
    IgnorePublicAcls=true,\
    BlockPublicPolicy=true,\
    RestrictPublicBuckets=true

# Cr√©er une table DynamoDB pour le state locking
aws dynamodb create-table \
  --table-name terraform-state-lock \
  --attribute-definitions AttributeName=LockID,AttributeType=S \
  --key-schema AttributeName=LockID,KeyType=HASH \
  --billing-mode PAY_PER_REQUEST \
  --region $REGION
```

#### √âtape 2 : Configurer le Backend

```hcl
# backend.tf
terraform {
  backend "s3" {
    bucket         = "my-terraform-state-1234567890"
    key            = "prod/terraform.tfstate"
    region         = "eu-west-1"
    encrypt        = true
    dynamodb_table = "terraform-state-lock"  # Pour le state locking
  }
}
```

#### √âtape 3 : Initialiser

```bash
terraform init
```

### Backend Terraform Cloud

#### √âtape 1 : Cr√©er un Compte

1. Aller sur https://app.terraform.io/
2. Cr√©er un compte
3. Cr√©er une organisation
4. Cr√©er un workspace

#### √âtape 2 : Configurer le Backend

```hcl
# backend.tf
terraform {
  cloud {
    organization = "my-org"

    workspaces {
      name = "my-app-prod"
    }
  }
}
```

#### √âtape 3 : S'Authentifier

```bash
# G√©n√©rer un token
terraform login

# Ou d√©finir manuellement
export TF_TOKEN_app_terraform_io="xxxxxxxx"
```

#### √âtape 4 : Initialiser

```bash
terraform init
```

---

## üîí State Locking

Le **state locking** emp√™che plusieurs personnes de modifier le state simultan√©ment.

### Azure Storage (Automatic Locking)

Azure Storage inclut automatiquement le state locking via des leases :

```hcl
terraform {
  backend "azurerm" {
    # Le locking est automatique
    resource_group_name  = "rg-terraform-state"
    storage_account_name = "sttfstate1234567890"
    container_name       = "tfstate"
    key                  = "prod.terraform.tfstate"
  }
}
```

### AWS S3 + DynamoDB (Manual Configuration)

Pour S3, utilisez DynamoDB pour le locking :

```hcl
terraform {
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "prod/terraform.tfstate"
    region         = "eu-west-1"
    dynamodb_table = "terraform-state-lock"  # Table DynamoDB pour locking
    encrypt        = true
  }
}
```

### Comportement du Locking

```bash
# Terminal 1
terraform apply
# Acquiert le lock...

# Terminal 2 (pendant l'apply du Terminal 1)
terraform apply
# Error: Error acquiring the state lock
# Lock Info:
#   ID:        abc123-def456-ghi789
#   Path:      prod/terraform.tfstate
#   Operation: OperationTypeApply
#   Who:       user@hostname
#   Version:   1.6.6
#   Created:   2025-11-01 10:30:15
```

### Forcer le D√©verrouillage (DANGER)

```bash
# Si un apply a crash√© et le lock n'a pas √©t√© lib√©r√©
terraform force-unlock LOCK_ID

# ‚ö†Ô∏è √Ä utiliser UNIQUEMENT si vous √™tes s√ªr que personne d'autre n'utilise le state
```

---

## üõ†Ô∏è Commandes State Avanc√©es

### `terraform state list` - Lister les Ressources

```bash
# Lister toutes les ressources dans le state
terraform state list

# Sortie :
# azurerm_resource_group.main
# azurerm_virtual_network.main
# azurerm_subnet.web
# azurerm_subnet.app
```

### `terraform state show` - Afficher une Ressource

```bash
# Afficher les d√©tails d'une ressource
terraform state show azurerm_resource_group.main

# Sortie :
# resource "azurerm_resource_group" "main" {
#     id       = "/subscriptions/.../resourceGroups/rg-prod"
#     location = "westeurope"
#     name     = "rg-prod"
#     tags     = {
#         "Environment" = "Production"
#     }
# }
```

### `terraform state mv` - Renommer une Ressource

```bash
# Renommer une ressource dans le state
terraform state mv azurerm_resource_group.main azurerm_resource_group.prod

# Ensuite, mettre √† jour le code :
# resource "azurerm_resource_group" "prod" {  # ‚Üê Chang√© de "main" √† "prod"
#   name = "rg-prod"
#   ...
# }
```

### `terraform state rm` - Retirer une Ressource du State

```bash
# Retirer une ressource du state (sans la supprimer dans le cloud)
terraform state rm azurerm_resource_group.main

# ‚ö†Ô∏è La ressource existe toujours dans Azure, mais Terraform ne la g√®re plus
```

**Cas d'usage :**
- Migrer une ressource vers un autre projet Terraform
- Passer d'une gestion Terraform √† une gestion manuelle

### `terraform state pull` - T√©l√©charger le State

```bash
# T√©l√©charger le state distant
terraform state pull > local_state.json

# Utile pour inspecter le state
```

### `terraform state push` - Uploader le State (DANGER)

```bash
# ‚ö†Ô∏è ATTENTION : Peut √©craser le state distant
terraform state push local_state.json

# √Ä utiliser UNIQUEMENT pour r√©cup√©rer d'un d√©sastre
```

### `terraform import` - Importer une Ressource Existante

```bash
# Importer un Resource Group existant
terraform import azurerm_resource_group.main /subscriptions/SUBSCRIPTION_ID/resourceGroups/existing-rg

# √âtapes :
# 1. Cr√©er le bloc resource vide dans le code
# 2. Ex√©cuter terraform import
# 3. Ex√©cuter terraform plan pour voir les diff√©rences
# 4. Ajuster le code pour correspondre √† la ressource
```

**Exemple complet :**

```hcl
# 1. Cr√©er le bloc vide
resource "azurerm_resource_group" "main" {
  # Ne pas remplir encore
}
```

```bash
# 2. Importer
terraform import azurerm_resource_group.main /subscriptions/xxx/resourceGroups/existing-rg

# 3. Voir ce qui manque
terraform plan

# 4. Compl√©ter le code
# resource "azurerm_resource_group" "main" {
#   name     = "existing-rg"
#   location = "West Europe"
#   tags = {
#     Environment = "Production"
#   }
# }

# 5. V√©rifier
terraform plan
# No changes. Your infrastructure matches the configuration.
```

---

## üîÑ Migration de Backend

### De Local vers Remote

#### √âtape 1 : √âtat Initial (Local)

```hcl
# Pas de configuration backend
terraform init
terraform apply
# Cr√©e : terraform.tfstate (local)
```

#### √âtape 2 : Ajouter la Configuration Backend

```hcl
# backend.tf
terraform {
  backend "azurerm" {
    resource_group_name  = "rg-terraform-state"
    storage_account_name = "sttfstate1234567890"
    container_name       = "tfstate"
    key                  = "prod.terraform.tfstate"
  }
}
```

#### √âtape 3 : R√©initialiser avec Migration

```bash
terraform init -migrate-state
```

**Sortie :**

```
Initializing the backend...
Terraform detected that the backend type changed from "local" to "azurerm".

Do you want to copy existing state to the new backend?
  Pre-existing state was found while migrating the previous "local" backend to the
  newly configured "azurerm" backend. No existing state was found in the newly
  configured "azurerm" backend. Do you want to copy this state to the new "azurerm"
  backend? Enter "yes" to copy and "no" to start with an empty state.

  Enter a value: yes

Successfully configured the backend "azurerm"! Terraform will automatically
use this backend unless the backend configuration changes.
```

Le state local est maintenant migr√© vers Azure Storage !

#### √âtape 4 : V√©rification

```bash
# V√©rifier que le state est bien distant
terraform state list

# Supprimer le state local (optionnel)
rm terraform.tfstate
rm terraform.tfstate.backup
```

### D'un Backend Remote √† un Autre

```bash
# 1. Modifier backend.tf avec le nouveau backend
# 2. R√©initialiser avec migration
terraform init -migrate-state -reconfigure
```

---

## üîê S√©curit√© du State

### Probl√®mes de S√©curit√©

Le state file peut contenir :
- ‚ùå Mots de passe en clair
- ‚ùå Cl√©s API
- ‚ùå Tokens d'authentification
- ‚ùå Informations sensibles

**Exemple :**

```json
{
  "resources": [
    {
      "type": "azurerm_postgresql_flexible_server",
      "instances": [
        {
          "attributes": {
            "administrator_password": "SuperSecretPassword123!",  # ‚Üê EN CLAIR !
            "connection_string": "postgresql://admin:SuperSecretPassword123!@..."
          }
        }
      ]
    }
  ]
}
```

### Best Practices de S√©curit√©

#### 1. Ne JAMAIS Versionner le State

```gitignore
# .gitignore
*.tfstate
*.tfstate.*
*.tfstate.backup
```

#### 2. Utiliser un Backend Chiffr√©

**Azure Storage :**
```bash
# Le Storage Account doit avoir le chiffrement activ√©
az storage account create \
  --encryption-services blob \
  --https-only true
```

**AWS S3 :**
```hcl
terraform {
  backend "s3" {
    bucket  = "my-terraform-state"
    key     = "prod/terraform.tfstate"
    encrypt = true  # ‚Üê Chiffrement activ√©
  }
}
```

#### 3. Contr√¥ler les Acc√®s

**Azure - RBAC :**
```bash
# Donner acc√®s uniquement aux utilisateurs n√©cessaires
az role assignment create \
  --assignee user@example.com \
  --role "Storage Blob Data Contributor" \
  --scope /subscriptions/.../resourceGroups/rg-terraform-state
```

**AWS - IAM Policy :**
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject"
      ],
      "Resource": "arn:aws:s3:::my-terraform-state/*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:PutItem",
        "dynamodb:DeleteItem"
      ],
      "Resource": "arn:aws:dynamodb:*:*:table/terraform-state-lock"
    }
  ]
}
```

#### 4. Utiliser `sensitive = true` pour les Variables

```hcl
variable "db_password" {
  type      = string
  sensitive = true  # ‚Üê Masqu√© dans les logs
}

output "db_endpoint" {
  value     = azurerm_postgresql_flexible_server.main.fqdn
  sensitive = true  # ‚Üê Masqu√© dans les outputs
}
```

#### 5. Activer le Versioning

**Azure Storage :**
```bash
az storage blob service-properties update \
  --account-name sttfstate1234567890 \
  --enable-versioning true
```

**AWS S3 :**
```bash
aws s3api put-bucket-versioning \
  --bucket my-terraform-state \
  --versioning-configuration Status=Enabled
```

---

## üë• Collaboration en √âquipe

### Workflow avec Backend Distant

```
D√©veloppeur 1                Backend (Azure Storage)              D√©veloppeur 2
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ               ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

terraform plan          ‚îÄ‚Üí  Acquiert le lock                ‚Üê‚îÄ  terraform plan (bloqu√©)
                            Lit le state
                            Calcule le plan
                                   ‚îÇ
terraform apply         ‚îÄ‚Üí  Modifie les ressources
                            Met √† jour le state
                            Lib√®re le lock
                                   ‚îÇ                          ‚îÄ‚Üí  terraform plan (OK)
                                   ‚îÇ                              Lit le nouveau state
                                   ‚îÇ                              Calcule le plan
                            ‚úÖ State √† jour
```

### Bonnes Pratiques en √âquipe

1. **Utiliser des Workspaces ou des Projets S√©par√©s**

```bash
# Cr√©er un workspace par environnement
terraform workspace new dev
terraform workspace new staging
terraform workspace new prod

# Lister les workspaces
terraform workspace list

# Changer de workspace
terraform workspace select prod
```

2. **Utiliser des Fichiers .tfvars par Environnement**

```
project/
‚îú‚îÄ‚îÄ backend.tf              # Backend partag√©
‚îú‚îÄ‚îÄ main.tf
‚îú‚îÄ‚îÄ variables.tf
‚îú‚îÄ‚îÄ dev.tfvars             # Valeurs dev
‚îú‚îÄ‚îÄ staging.tfvars         # Valeurs staging
‚îî‚îÄ‚îÄ prod.tfvars            # Valeurs prod
```

3. **Communication dans l'√âquipe**

- Annoncer avant de faire un `terraform apply`
- Utiliser des branches Git s√©par√©es
- Faire des code reviews avant de merger
- Automatiser avec CI/CD (Module 8)

---

## üìù Points Cl√©s √† Retenir

1. **State** : Contient le mapping entre le code et l'infrastructure r√©elle
2. **Backend Remote** : Obligatoire pour le travail en √©quipe
3. **State Locking** : √âvite les conflits lors d'ex√©cutions simultan√©es
4. **S√©curit√©** : Ne jamais versionner le state, utiliser le chiffrement
5. **Commandes State** : `list`, `show`, `mv`, `rm`, `import`
6. **Migration** : `terraform init -migrate-state`
7. **Collaboration** : Backend distant + locking + workspaces

---

## ‚úÖ Quiz de Compr√©hension

1. Pourquoi ne doit-on JAMAIS versionner le state file dans Git ?
2. Qu'est-ce que le state locking et pourquoi est-il important ?
3. Comment migrer un state local vers Azure Storage ?
4. Quelle commande permet d'importer une ressource existante ?
5. Quelles sont les 3 meilleures pratiques de s√©curit√© pour le state ?

---

## üöÄ Prochaine √âtape

Vous ma√Ætrisez maintenant la gestion du state ! Il est temps de rendre votre code r√©utilisable avec les modules.

**‚û°Ô∏è [Module 7 : Modules Terraform](07-modules.md)**

Dans le prochain module, vous allez :
- Comprendre les modules Terraform
- Cr√©er votre premier module custom
- Utiliser des modules du Terraform Registry
- Versionner vos modules
- Structurer un projet avec des modules

---

## üìö Ressources Compl√©mentaires

- [State File](https://www.terraform.io/docs/language/state/index.html)
- [Backend Configuration](https://www.terraform.io/docs/language/settings/backends/index.html)
- [State Locking](https://www.terraform.io/docs/language/state/locking.html)
- [Azure Backend](https://www.terraform.io/docs/language/settings/backends/azurerm.html)
- [S3 Backend](https://www.terraform.io/docs/language/settings/backends/s3.html)

---

[‚¨ÖÔ∏è Module pr√©c√©dent](05-ressources-cloud.md) | [üè† Retour √† l'accueil](../README.md) | [‚û°Ô∏è Module suivant](07-modules.md)
