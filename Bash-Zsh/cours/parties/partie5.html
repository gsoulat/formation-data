<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Partie 5 - Structures de Contr√¥le et Boucles</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">

    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <link rel="stylesheet" href="../assets/styles.css">
</head>

<body>
    <div class="container">
        <header>
            <h1>üîÄ Partie 5</h1>
            <p class="subtitle">Structures de Contr√¥le et Boucles</p>
            <span class="duration">‚è±Ô∏è Dur√©e : 40 minutes</span>
        </header>

        <nav class="nav-menu">
            <ul>
                <li><a href="../index.html">üè† Accueil</a></li>
                <li><a href="partie4.html">‚Üê Partie 4</a></li>
                <li><a href="partie6.html">Partie 6 ‚Üí</a></li>
            </ul>
        </nav>

        <div class="content">
            <section class="section">
                <h2>5. Structures de Contr√¥le et Boucles</h2>

                <p>Les structures de contr√¥le permettent de cr√©er des scripts intelligents qui prennent des d√©cisions et r√©p√®tent des op√©rations. Essentielles pour l'automatisation.</p>

                <h3>Conditions : if / elif / else</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# Syntaxe de base
if [ condition ]; then
    # commandes si vrai
fi

# Avec else
if [ condition ]; then
    # commandes si vrai
else
    # commandes si faux
fi

# Avec elif (else if)
if [ condition1 ]; then
    # commandes si condition1 vraie
elif [ condition2 ]; then
    # commandes si condition2 vraie
else
    # commandes si toutes fausses
fi

# Exemples pratiques
age=25

if [ $age -ge 18 ]; then
    echo "Majeur"
else
    echo "Mineur"
fi

# Multiple conditions
if [ $age -ge 18 ] && [ $age -le 65 ]; then
    echo "√Çge actif"
elif [ $age -gt 65 ]; then
    echo "Senior"
else
    echo "Jeune"
fi

# V√©rifier l'existence d'un fichier
filename="data.csv"

if [ -f "$filename" ]; then
    echo "Le fichier existe"
    lines=$(wc -l < "$filename")
    echo "Nombre de lignes: $lines"
else
    echo "Le fichier n'existe pas"
    exit 1
fi

# Forme compacte (une ligne)
[ -f "$filename" ] && echo "File exists" || echo "File not found"</code></pre>
                </div>

                <h3>Tests : [ ], [[ ]], et test</h3>

                <div class="alert alert-info">
                    <h4>Diff√©rences entre [ ] et [[ ]]</h4>
                    <p>
                        <code>[ ]</code> : Syntaxe POSIX classique (compatible partout)<br>
                        <code>[[ ]]</code> : Syntaxe Bash/Zsh moderne (plus puissante, recommand√©e)<br>
                        <code>test</code> : √âquivalent de [ ]
                    </p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash"># [ ] : Syntaxe classique
if [ "$var" = "value" ]; then
    echo "Equal"
fi

# [[ ]] : Syntaxe moderne (recommand√©e)
if [[ "$var" == "value" ]]; then
    echo "Equal"
fi

# Avantages de [[ ]]
# - Pas besoin de quoter les variables
# - Support des regex
# - Op√©rateurs && et || directement
# - Pattern matching

# Exemples avec [[ ]]
name="Alice"

if [[ $name == "Alice" ]]; then
    echo "Hello Alice"
fi

# Pattern matching
if [[ $name == A* ]]; then
    echo "Name starts with A"
fi

# Regex
if [[ $name =~ ^[A-Z][a-z]+$ ]]; then
    echo "Valid name format"
fi

# Op√©rateurs logiques
if [[ $age -gt 18 && $age -lt 65 ]]; then
    echo "Working age"
fi

# Avec [ ] il faut utiliser -a et -o ou s√©parer
if [ $age -gt 18 ] && [ $age -lt 65 ]; then
    echo "Working age"
fi</code></pre>
                </div>

                <h3>Op√©rateurs de comparaison</h3>

                <h4>Comparaisons num√©riques</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Op√©rateur</th>
                            <th>Description</th>
                            <th>Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>-eq</code></td>
                            <td>√âgal (equal)</td>
                            <td><code>[ $a -eq $b ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-ne</code></td>
                            <td>Diff√©rent (not equal)</td>
                            <td><code>[ $a -ne $b ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-gt</code></td>
                            <td>Plus grand (greater than)</td>
                            <td><code>[ $a -gt $b ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-ge</code></td>
                            <td>Plus grand ou √©gal (greater or equal)</td>
                            <td><code>[ $a -ge $b ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-lt</code></td>
                            <td>Plus petit (less than)</td>
                            <td><code>[ $a -lt $b ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-le</code></td>
                            <td>Plus petit ou √©gal (less or equal)</td>
                            <td><code>[ $a -le $b ]</code></td>
                        </tr>
                    </tbody>
                </table>

                <h4>Comparaisons de cha√Ænes</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Op√©rateur</th>
                            <th>Description</th>
                            <th>Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>=</code> ou <code>==</code></td>
                            <td>√âgal</td>
                            <td><code>[ "$a" = "$b" ]</code></td>
                        </tr>
                        <tr>
                            <td><code>!=</code></td>
                            <td>Diff√©rent</td>
                            <td><code>[ "$a" != "$b" ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-z</code></td>
                            <td>Cha√Æne vide (zero length)</td>
                            <td><code>[ -z "$var" ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-n</code></td>
                            <td>Cha√Æne non vide</td>
                            <td><code>[ -n "$var" ]</code></td>
                        </tr>
                        <tr>
                            <td><code>&lt;</code></td>
                            <td>Avant dans l'ordre alphab√©tique</td>
                            <td><code>[[ "$a" &lt; "$b" ]]</code></td>
                        </tr>
                        <tr>
                            <td><code>&gt;</code></td>
                            <td>Apr√®s dans l'ordre alphab√©tique</td>
                            <td><code>[[ "$a" &gt; "$b" ]]</code></td>
                        </tr>
                    </tbody>
                </table>

                <h4>Tests de fichiers</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Op√©rateur</th>
                            <th>Description</th>
                            <th>Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>-f</code></td>
                            <td>Fichier existe et est r√©gulier</td>
                            <td><code>[ -f file.txt ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-d</code></td>
                            <td>R√©pertoire existe</td>
                            <td><code>[ -d /path ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-e</code></td>
                            <td>Fichier ou r√©pertoire existe</td>
                            <td><code>[ -e path ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-s</code></td>
                            <td>Fichier existe et non vide</td>
                            <td><code>[ -s file.txt ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-r</code></td>
                            <td>Fichier lisible</td>
                            <td><code>[ -r file.txt ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-w</code></td>
                            <td>Fichier modifiable</td>
                            <td><code>[ -w file.txt ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-x</code></td>
                            <td>Fichier ex√©cutable</td>
                            <td><code>[ -x script.sh ]</code></td>
                        </tr>
                        <tr>
                            <td><code>-L</code></td>
                            <td>Lien symbolique</td>
                            <td><code>[ -L link ]</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# Comparaisons num√©riques
count=10

if [ $count -eq 10 ]; then
    echo "Count is 10"
fi

if [ $count -gt 5 ]; then
    echo "Count is greater than 5"
fi

# Comparaisons de cha√Ænes
name="Alice"

if [ "$name" = "Alice" ]; then
    echo "Hello Alice"
fi

if [ -z "$name" ]; then
    echo "Name is empty"
fi

if [ -n "$name" ]; then
    echo "Name is not empty"
fi

# Tests de fichiers
file="data.csv"

if [ -f "$file" ]; then
    echo "File exists"

    if [ -s "$file" ]; then
        echo "File is not empty"
    fi

    if [ -r "$file" ]; then
        echo "File is readable"
    fi
fi

if [ -d "/tmp" ]; then
    echo "/tmp directory exists"
fi

# Tests combin√©s
if [ -f "$file" ] && [ -s "$file" ]; then
    echo "File exists and is not empty"
fi

# Avec [[]]
if [[ -f "$file" && -s "$file" ]]; then
    echo "File exists and is not empty"
fi

# Pattern matching
filename="data.csv"

if [[ $filename == *.csv ]]; then
    echo "This is a CSV file"
fi

if [[ $filename =~ ^data_[0-9]+\.csv$ ]]; then
    echo "Matches pattern: data_NUMBER.csv"
fi

# Exemple pratique : validation d'entr√©es
validate_input() {
    local input=$1

    # V√©rifier que l'input n'est pas vide
    if [ -z "$input" ]; then
        echo "Error: Input is empty"
        return 1
    fi

    # V√©rifier que c'est un nombre
    if ! [[ $input =~ ^[0-9]+$ ]]; then
        echo "Error: Input is not a number"
        return 1
    fi

    # V√©rifier la plage
    if [ $input -lt 1 ] || [ $input -gt 100 ]; then
        echo "Error: Input must be between 1 and 100"
        return 1
    fi

    echo "Input is valid"
    return 0
}</code></pre>
                </div>

                <h3>Boucle for</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# Boucle sur une liste
for item in item1 item2 item3; do
    echo "Item: $item"
done

# Boucle sur des fichiers
for file in *.csv; do
    echo "Processing $file"
    wc -l "$file"
done

# Boucle sur une s√©quence de nombres
for i in {1..5}; do
    echo "Number: $i"
done

# Boucle avec seq
for i in $(seq 1 10); do
    echo "Iteration $i"
done

# Style C (arithm√©tique)
for ((i=1; i<=10; i++)); do
    echo "Count: $i"
done

# Boucle sur les arguments du script
for arg in "$@"; do
    echo "Argument: $arg"
done

# Boucle sur les lignes d'un fichier
for line in $(cat file.txt); do
    echo "Line: $line"
done

# Meilleure m√©thode pour lire un fichier (pr√©serve les espaces)
while IFS= read -r line; do
    echo "Line: $line"
done < file.txt

# Exemples pratiques en Data Engineering

# 1. Traiter tous les CSV d'un dossier
for csv_file in data/raw/*.csv; do
    echo "Processing $csv_file..."
    # Compter les lignes
    lines=$(wc -l < "$csv_file")
    echo "  Lines: $lines"

    # Extraire le nom sans extension
    basename=$(basename "$csv_file" .csv)
    echo "  Basename: $basename"

    # Copier vers processed
    cp "$csv_file" "data/processed/${basename}_processed.csv"
done

# 2. Cr√©er des dossiers pour chaque mois
for month in {01..12}; do
    mkdir -p "data/2024/$month"
    echo "Created data/2024/$month"
done

# 3. T√©l√©charger plusieurs fichiers
urls=(
    "https://example.com/data1.csv"
    "https://example.com/data2.csv"
    "https://example.com/data3.csv"
)

for url in "${urls[@]}"; do
    filename=$(basename "$url")
    echo "Downloading $filename..."
    curl -O "$url"
done

# 4. Traiter des fichiers avec pattern
for year in 2020 2021 2022 2023; do
    for month in {01..12}; do
        file="sales_${year}_${month}.csv"
        if [ -f "$file" ]; then
            echo "Processing $file"
            # Votre traitement ici
        fi
    done
done

# 5. Renommer des fichiers en masse
for file in *.txt; do
    newname="${file%.txt}_backup.txt"
    mv "$file" "$newname"
    echo "Renamed $file to $newname"
done

# 6. Ex√©cuter une commande sur plusieurs serveurs
servers=(server1 server2 server3)

for server in "${servers[@]}"; do
    echo "Connecting to $server..."
    ssh "$server" "df -h"
done</code></pre>
                </div>

                <h3>Boucle while</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# While basique
counter=1
while [ $counter -le 5 ]; do
    echo "Counter: $counter"
    ((counter++))
done

# While avec lecture de fichier (m√©thode recommand√©e)
while IFS= read -r line; do
    echo "Line: $line"
done < data.txt

# While avec CSV (s√©parateur personnalis√©)
while IFS=',' read -r col1 col2 col3; do
    echo "Col1: $col1, Col2: $col2, Col3: $col3"
done < data.csv

# While infini (avec break)
while true; do
    read -p "Enter command (or 'quit'): " cmd

    if [ "$cmd" = "quit" ]; then
        break
    fi

    echo "You entered: $cmd"
done

# While avec condition de fichier
while [ ! -f "signal.txt" ]; do
    echo "Waiting for signal file..."
    sleep 5
done
echo "Signal file found!"

# Exemples pratiques

# 1. Lire un CSV ligne par ligne
while IFS=',' read -r id name age salary; do
    # Ignorer le header
    if [ "$id" = "id" ]; then
        continue
    fi

    # Traiter chaque ligne
    echo "Processing employee: $name"

    # Filtrer par condition
    if [ $salary -gt 50000 ]; then
        echo "$name has high salary: $salary"
    fi
done < employees.csv

# 2. Attendre qu'un processus se termine
while pgrep -x "process_name" > /dev/null; do
    echo "Process still running..."
    sleep 10
done
echo "Process finished"

# 3. Monitorer l'espace disque
while true; do
    usage=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')

    if [ $usage -gt 80 ]; then
        echo "WARNING: Disk usage is ${usage}%"
        # Envoyer une alerte
    fi

    sleep 3600  # V√©rifier chaque heure
done

# 4. Traiter des fichiers jusqu'√† ce qu'il n'y en ait plus
while [ -n "$(ls queue/*.csv 2>/dev/null)" ]; do
    for file in queue/*.csv; do
        echo "Processing $file"
        # Traiter le fichier
        process_file "$file"
        # D√©placer vers processed
        mv "$file" processed/
    done
    sleep 60  # Attendre 1 minute
done

# 5. Lire des logs en temps r√©el et filtrer
tail -f application.log | while read -r line; do
    if [[ $line =~ ERROR ]]; then
        echo "ERROR DETECTED: $line"
        # Envoyer une notification
    fi
done</code></pre>
                </div>

                <h3>Boucle until</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# Until : boucle jusqu'√† ce que la condition soit vraie
# (oppos√© de while)

counter=1
until [ $counter -gt 5 ]; do
    echo "Counter: $counter"
    ((counter++))
done

# Attendre qu'un fichier existe
until [ -f "data.csv" ]; do
    echo "Waiting for data.csv..."
    sleep 5
done
echo "File found!"

# Attendre qu'un service soit pr√™t
until curl -s http://localhost:8080/health > /dev/null; do
    echo "Waiting for service to be ready..."
    sleep 2
done
echo "Service is ready!"

# Exemple pratique : retry mechanism
max_retries=5
retry_count=0

until process_data || [ $retry_count -eq $max_retries ]; do
    ((retry_count++))
    echo "Attempt $retry_count failed. Retrying..."
    sleep 5
done

if [ $retry_count -eq $max_retries ]; then
    echo "Failed after $max_retries attempts"
    exit 1
fi</code></pre>
                </div>

                <h3>Case statements (switch)</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# Syntaxe case
case $variable in
    pattern1)
        # commandes
        ;;
    pattern2)
        # commandes
        ;;
    *)
        # d√©faut
        ;;
esac

# Exemple simple
read -p "Enter a choice (a/b/c): " choice

case $choice in
    a)
        echo "You chose A"
        ;;
    b)
        echo "You chose B"
        ;;
    c)
        echo "You chose C"
        ;;
    *)
        echo "Invalid choice"
        ;;
esac

# Patterns multiples
read -p "Enter yes or no: " answer

case $answer in
    yes|y|Y|YES)
        echo "You said yes"
        ;;
    no|n|N|NO)
        echo "You said no"
        ;;
    *)
        echo "Please answer yes or no"
        ;;
esac

# Pattern matching
filename="data.csv"

case $filename in
    *.csv)
        echo "CSV file"
        ;;
    *.json)
        echo "JSON file"
        ;;
    *.xml)
        echo "XML file"
        ;;
    *)
        echo "Unknown file type"
        ;;
esac

# Exemple pratique : menu de script
show_menu() {
    echo "========== Data Pipeline Menu =========="
    echo "1. Extract data"
    echo "2. Transform data"
    echo "3. Load data"
    echo "4. Run full pipeline"
    echo "5. Generate report"
    echo "q. Quit"
    echo "========================================"
}

while true; do
    show_menu
    read -p "Enter your choice: " choice

    case $choice in
        1)
            echo "Extracting data..."
            extract_data
            ;;
        2)
            echo "Transforming data..."
            transform_data
            ;;
        3)
            echo "Loading data..."
            load_data
            ;;
        4)
            echo "Running full pipeline..."
            extract_data
            transform_data
            load_data
            ;;
        5)
            echo "Generating report..."
            generate_report
            ;;
        q|Q)
            echo "Goodbye!"
            exit 0
            ;;
        *)
            echo "Invalid choice. Please try again."
            ;;
    esac

    echo ""
done

# Parser des options avec case
while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        -o|--output)
            OUTPUT_FILE=$2
            shift 2
            ;;
        -f|--format)
            case $2 in
                csv|json|xml)
                    FORMAT=$2
                    shift 2
                    ;;
                *)
                    echo "Invalid format: $2"
                    exit 1
                    ;;
            esac
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done</code></pre>
                </div>

                <h3>Break et Continue</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# break : sortir de la boucle
for i in {1..10}; do
    if [ $i -eq 5 ]; then
        echo "Breaking at $i"
        break
    fi
    echo "Number: $i"
done
# Output: 1, 2, 3, 4, Breaking at 5

# continue : passer √† l'it√©ration suivante
for i in {1..10}; do
    if [ $i -eq 5 ]; then
        echo "Skipping $i"
        continue
    fi
    echo "Number: $i"
done
# Output: 1, 2, 3, 4, Skipping 5, 6, 7, 8, 9, 10

# Exemple pratique : traiter des fichiers avec erreurs
for file in *.csv; do
    # V√©rifier que le fichier existe et n'est pas vide
    if [ ! -s "$file" ]; then
        echo "Skipping empty file: $file"
        continue
    fi

    echo "Processing $file..."

    # Si erreur critique, arr√™ter tout
    if ! validate_csv "$file"; then
        echo "Critical error in $file. Stopping."
        break
    fi

    # Traiter le fichier
    process_csv "$file"
done

# break avec niveau (sortir de plusieurs boucles)
for i in {1..3}; do
    for j in {1..3}; do
        echo "i=$i, j=$j"
        if [ $i -eq 2 ] && [ $j -eq 2 ]; then
            break 2  # Sortir des 2 boucles
        fi
    done
done

# Exemple : chercher un fichier dans plusieurs dossiers
found=0
for dir in dir1 dir2 dir3; do
    for file in "$dir"/*.csv; do
        if [[ $file =~ important ]]; then
            echo "Found: $file"
            found=1
            break 2
        fi
    done
done

if [ $found -eq 0 ]; then
    echo "File not found"
fi</code></pre>
                </div>

                <h3>Exemple complet : Script de traitement batch</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/usr/bin/env bash
#
# Script: batch_processor.sh
# Description: Traite plusieurs fichiers CSV en batch
#

set -euo pipefail

# Variables
readonly INPUT_DIR="data/raw"
readonly OUTPUT_DIR="data/processed"
readonly ERROR_DIR="data/errors"
readonly LOG_FILE="batch_$(date +%Y%m%d_%H%M%S).log"

# Compteurs
total_files=0
processed_files=0
error_files=0

# Cr√©er les dossiers n√©cessaires
mkdir -p "$OUTPUT_DIR" "$ERROR_DIR"

# Fonction de logging
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

# Fonction de validation
validate_csv() {
    local file=$1

    # V√©rifier que le fichier n'est pas vide
    if [ ! -s "$file" ]; then
        log "ERROR: File is empty: $file"
        return 1
    fi

    # V√©rifier le nombre de colonnes
    local expected_cols=5
    local actual_cols=$(head -1 "$file" | awk -F',' '{print NF}')

    if [ $actual_cols -ne $expected_cols ]; then
        log "ERROR: Expected $expected_cols columns, got $actual_cols in $file"
        return 1
    fi

    return 0
}

# Fonction de traitement
process_csv() {
    local input_file=$1
    local basename=$(basename "$input_file" .csv)
    local output_file="$OUTPUT_DIR/${basename}_processed.csv"

    log "Processing: $input_file"

    # Traitement : supprimer les lignes vides et nettoyer
    sed '/^$/d' "$input_file" | \
        sed 's/^[[:space:]]*//; s/[[:space:]]*$//' > "$output_file"

    # V√©rifier le r√©sultat
    if [ -s "$output_file" ]; then
        local input_lines=$(wc -l < "$input_file")
        local output_lines=$(wc -l < "$output_file")
        log "SUCCESS: $input_file -> $output_file ($input_lines -> $output_lines lines)"
        return 0
    else
        log "ERROR: Output file is empty: $output_file"
        rm -f "$output_file"
        return 1
    fi
}

# Fonction principale
main() {
    log "=== Batch Processing Started ==="
    log "Input directory: $INPUT_DIR"
    log "Output directory: $OUTPUT_DIR"

    # V√©rifier que le dossier input existe
    if [ ! -d "$INPUT_DIR" ]; then
        log "ERROR: Input directory not found: $INPUT_DIR"
        exit 1
    fi

    # Compter les fichiers
    total_files=$(find "$INPUT_DIR" -name "*.csv" -type f | wc -l)

    if [ $total_files -eq 0 ]; then
        log "WARNING: No CSV files found in $INPUT_DIR"
        exit 0
    fi

    log "Found $total_files files to process"

    # Traiter chaque fichier
    for csv_file in "$INPUT_DIR"/*.csv; do
        # V√©rifier que le fichier existe (pour √©viter l'erreur si aucun CSV)
        [ -f "$csv_file" ] || continue

        # Validation
        if ! validate_csv "$csv_file"; then
            log "SKIPPING: Validation failed for $csv_file"
            mv "$csv_file" "$ERROR_DIR/"
            ((error_files++))
            continue
        fi

        # Traitement
        if process_csv "$csv_file"; then
            ((processed_files++))
        else
            log "MOVING TO ERROR: $csv_file"
            mv "$csv_file" "$ERROR_DIR/"
            ((error_files++))
        fi

        # Pause courte entre les fichiers
        sleep 0.5
    done

    # Rapport final
    log "=== Batch Processing Completed ==="
    log "Total files: $total_files"
    log "Successfully processed: $processed_files"
    log "Errors: $error_files"
    log "Success rate: $(( processed_files * 100 / total_files ))%"

    # Code de retour
    if [ $error_files -gt 0 ]; then
        exit 1
    else
        exit 0
    fi
}

# Ex√©cuter
main "$@"</code></pre>
                </div>

                <h3>Exercices pratiques</h3>

                <div class="exercise">
                    <h4>üéØ Exercice 1 : Validation avec conditions</h4>
                    <p>Cr√©ez un script qui valide un fichier CSV :</p>
                    <ol>
                        <li>V√©rifie que le fichier existe</li>
                        <li>V√©rifie qu'il n'est pas vide</li>
                        <li>Compte le nombre de lignes</li>
                        <li>Affiche "VALID" si plus de 10 lignes, "TOO SHORT" sinon</li>
                    </ol>

                    <details class="exercise-solution">
                        <summary>üí° Voir la solution</summary>
                        <div class="code-container">
                            <pre><code class="language-bash">#!/bin/bash
set -euo pipefail

file=$1

if [ ! -f "$file" ]; then
    echo "ERROR: File not found"
    exit 1
fi

if [ ! -s "$file" ]; then
    echo "ERROR: File is empty"
    exit 1
fi

lines=$(wc -l < "$file")
echo "Lines: $lines"

if [ $lines -gt 10 ]; then
    echo "VALID"
else
    echo "TOO SHORT"
fi</code></pre>
                        </div>
                    </details>
                </div>

                <div class="exercise">
                    <h4>üéØ Exercice 2 : Boucle de traitement</h4>
                    <p>Cr√©ez un script qui :</p>
                    <ol>
                        <li>Boucle sur tous les fichiers CSV d'un dossier</li>
                        <li>Pour chaque fichier, compte les lignes</li>
                        <li>Si plus de 100 lignes : copie dans "large/"</li>
                        <li>Si moins de 100 lignes : copie dans "small/"</li>
                        <li>Affiche un r√©sum√© √† la fin</li>
                    </ol>

                    <details class="exercise-solution">
                        <summary>üí° Voir la solution</summary>
                        <div class="code-container">
                            <pre><code class="language-bash">#!/bin/bash
set -euo pipefail

mkdir -p large small

large_count=0
small_count=0

for file in *.csv; do
    [ -f "$file" ] || continue

    lines=$(wc -l < "$file")

    if [ $lines -gt 100 ]; then
        cp "$file" large/
        echo "$file -> large/ ($lines lines)"
        ((large_count++))
    else
        cp "$file" small/
        echo "$file -> small/ ($lines lines)"
        ((small_count++))
    fi
done

echo ""
echo "Summary:"
echo "Large files: $large_count"
echo "Small files: $small_count"
echo "Total: $((large_count + small_count))"</code></pre>
                        </div>
                    </details>
                </div>

                <div class="alert alert-success">
                    <h4>üí° Points cl√©s √† retenir</h4>
                    <ul>
                        <li><code>if [ condition ]; then ... fi</code> : conditions</li>
                        <li><code>[[ ]]</code> : pr√©f√©rer √† <code>[ ]</code> (plus puissant)</li>
                        <li><code>-eq, -ne, -gt, -lt</code> : comparaisons num√©riques</li>
                        <li><code>-f, -d, -s, -z, -n</code> : tests de fichiers et cha√Ænes</li>
                        <li><code>for item in list; do ... done</code> : boucle for</li>
                        <li><code>while [ condition ]; do ... done</code> : boucle while</li>
                        <li><code>case var in pattern) ... ;; esac</code> : switch</li>
                        <li><code>break</code> et <code>continue</code> : contr√¥le de boucles</li>
                    </ul>
                </div>
            </section>

            <div class="alert alert-success">
                <h4>‚úÖ Partie 5 termin√©e !</h4>
                <p>
                    Vous ma√Ætrisez maintenant les structures de contr√¥le et les boucles. Vous pouvez cr√©er des scripts
                    intelligents et automatis√©s. Passez √† la Partie 6 pour les fonctions et outils avanc√©s.
                </p>
                <p style="margin-top: 20px;">
                    <a href="partie6.html"
                        style="display: inline-block; padding: 12px 25px; background: #0066cc; color: white; text-decoration: none; border-radius: 8px; font-weight: 600;">
                        Partie 6 : Fonctions et Outils Avanc√©s ‚Üí
                    </a>
                </p>
            </div>
        </div>

        <footer>
            <p>Formation Bash/Zsh pour Data Engineering - 2024</p>
            <p><a href="../index.html">‚Üê Retour √† l'accueil</a></p>
        </footer>
    </div>

    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</body>

</html>
