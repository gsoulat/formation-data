<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Partie 4 - Scripts Shell et Automatisation</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">

    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <link rel="stylesheet" href="../assets/styles.css">
</head>

<body>
    <div class="container">
        <header>
            <h1>üîß Partie 4</h1>
            <p class="subtitle">Scripts Shell et Automatisation</p>
            <span class="duration">‚è±Ô∏è Dur√©e : 45 minutes</span>
        </header>

        <nav class="nav-menu">
            <ul>
                <li><a href="../index.html">üè† Accueil</a></li>
                <li><a href="partie3.html">‚Üê Partie 3</a></li>
                <li><a href="partie5.html">Partie 5 ‚Üí</a></li>
            </ul>
        </nav>

        <div class="content">
            <section class="section">
                <h2>4. Scripts Shell et Automatisation</h2>

                <p>Un script shell est un fichier contenant une s√©rie de commandes qui peuvent √™tre ex√©cut√©es automatiquement. C'est la base de l'automatisation en Data Engineering.</p>

                <h3>Cr√©er votre premier script</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash"># Cr√©er un fichier script
touch hello.sh

# Ajouter le contenu
cat > hello.sh << 'EOF'
#!/bin/bash
# Mon premier script

echo "Hello, World!"
echo "Date: $(date)"
echo "User: $(whoami)"
EOF

# Rendre ex√©cutable
chmod +x hello.sh

# Ex√©cuter
./hello.sh</code></pre>
                </div>

                <h3>Le Shebang (#!/bin/bash)</h3>

                <div class="alert alert-info">
                    <h4>Qu'est-ce que le shebang ?</h4>
                    <p>
                        La premi√®re ligne d'un script shell doit commencer par <code>#!</code> (shebang) suivi du chemin vers l'interpr√©teur.
                        Cela indique au syst√®me quel programme utiliser pour ex√©cuter le script.
                    </p>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Shebang</th>
                            <th>Description</th>
                            <th>Usage</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>#!/bin/bash</code></td>
                            <td>Utilise Bash</td>
                            <td>Scripts Bash classiques</td>
                        </tr>
                        <tr>
                            <td><code>#!/bin/zsh</code></td>
                            <td>Utilise Zsh</td>
                            <td>Scripts Zsh sp√©cifiques</td>
                        </tr>
                        <tr>
                            <td><code>#!/bin/sh</code></td>
                            <td>Utilise sh (POSIX)</td>
                            <td>Scripts portables</td>
                        </tr>
                        <tr>
                            <td><code>#!/usr/bin/env bash</code></td>
                            <td>Cherche bash dans le PATH</td>
                            <td>Portabilit√© maximale</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash
# Script avec shebang Bash

#!/usr/bin/env bash
# Meilleure portabilit√© (recommand√©)

#!/bin/zsh
# Script Zsh sp√©cifique

#!/usr/bin/env python3
# Oui, √ßa marche aussi pour Python !</code></pre>
                </div>

                <h3>Variables</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# D√©finir une variable (pas d'espace autour du =)
name="Alice"
age=30
city="Paris"

# Utiliser une variable avec $
echo "Name: $name"
echo "Age: $age"
echo "City: $city"

# Meilleure pratique : utiliser des accolades
echo "Hello, ${name}!"

# Variables en lecture seule (constantes)
readonly DB_HOST="localhost"
readonly DB_PORT=5432

# Variables d'environnement
export API_KEY="secret123"
export ENV="production"

# Command substitution (capturer la sortie d'une commande)
current_date=$(date +%Y-%m-%d)
file_count=$(ls | wc -l)
current_dir=$(pwd)

echo "Date: $current_date"
echo "Files: $file_count"
echo "Directory: $current_dir"

# Ancienne syntaxe (backticks) - √† √©viter
old_syntax=`date`

# Variables sp√©ciales
echo "Script name: $0"
echo "PID: $$"
echo "Home: $HOME"
echo "User: $USER"
echo "Path: $PATH"</code></pre>
                </div>

                <h3>Param√®tres et arguments</h3>

                <table class="command-table">
                    <thead>
                        <tr>
                            <th>Variable</th>
                            <th>Description</th>
                            <th>Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>$0</code></td>
                            <td>Nom du script</td>
                            <td><code>echo $0</code></td>
                        </tr>
                        <tr>
                            <td><code>$1, $2, $3...</code></td>
                            <td>Arguments positionnels</td>
                            <td><code>echo $1</code></td>
                        </tr>
                        <tr>
                            <td><code>$@</code></td>
                            <td>Tous les arguments (liste)</td>
                            <td><code>echo "$@"</code></td>
                        </tr>
                        <tr>
                            <td><code>$*</code></td>
                            <td>Tous les arguments (cha√Æne unique)</td>
                            <td><code>echo "$*"</code></td>
                        </tr>
                        <tr>
                            <td><code>$#</code></td>
                            <td>Nombre d'arguments</td>
                            <td><code>echo $#</code></td>
                        </tr>
                        <tr>
                            <td><code>$?</code></td>
                            <td>Code de retour de la derni√®re commande</td>
                            <td><code>echo $?</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash
# Script: process_data.sh

echo "Script name: $0"
echo "First argument: $1"
echo "Second argument: $2"
echo "All arguments: $@"
echo "Number of arguments: $#"

# Exemple d'utilisation
# ./process_data.sh input.csv output.csv
# Output:
# Script name: ./process_data.sh
# First argument: input.csv
# Second argument: output.csv
# All arguments: input.csv output.csv
# Number of arguments: 2

# V√©rifier le nombre d'arguments
if [ $# -ne 2 ]; then
    echo "Usage: $0 <input_file> <output_file>"
    exit 1
fi

input_file=$1
output_file=$2

echo "Processing $input_file..."
echo "Output will be saved to $output_file"

# Traiter tous les arguments
for arg in "$@"; do
    echo "Argument: $arg"
done</code></pre>
                </div>

                <h3>Lecture d'entr√©es utilisateur</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# Lecture simple
echo "Enter your name:"
read name
echo "Hello, $name!"

# Lecture avec prompt
read -p "Enter your age: " age
echo "You are $age years old"

# Lecture s√©curis√©e (masquer la saisie) - pour passwords
read -sp "Enter password: " password
echo  # Nouvelle ligne
echo "Password saved"

# Lecture avec valeur par d√©faut
read -p "Enter environment [dev]: " env
env=${env:-dev}
echo "Environment: $env"

# Lecture de plusieurs valeurs
read -p "Enter first and last name: " first last
echo "First: $first, Last: $last"

# Lire ligne par ligne depuis un fichier
while IFS= read -r line; do
    echo "Line: $line"
done < data.txt

# Exemple pratique : configuration interactive
read -p "Enter database host [localhost]: " db_host
db_host=${db_host:-localhost}

read -p "Enter database port [5432]: " db_port
db_port=${db_port:-5432}

read -p "Enter database name: " db_name

echo "Configuration:"
echo "  Host: $db_host"
echo "  Port: $db_port"
echo "  Database: $db_name"</code></pre>
                </div>

                <h3>set -euo pipefail : Mode strict</h3>

                <div class="alert alert-warning">
                    <h4>‚ö†Ô∏è Bonnes pratiques : Mode strict</h4>
                    <p>
                        Ajoutez toujours <code>set -euo pipefail</code> au d√©but de vos scripts de production.
                        Cela rend vos scripts plus robustes et √©vite les erreurs silencieuses.
                    </p>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Option</th>
                            <th>Description</th>
                            <th>Effet</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>set -e</code></td>
                            <td>Exit on error</td>
                            <td>Arr√™te le script si une commande √©choue</td>
                        </tr>
                        <tr>
                            <td><code>set -u</code></td>
                            <td>Unset variables</td>
                            <td>Erreur si utilisation d'une variable non d√©finie</td>
                        </tr>
                        <tr>
                            <td><code>set -o pipefail</code></td>
                            <td>Pipeline failure</td>
                            <td>Pipeline √©choue si une commande √©choue</td>
                        </tr>
                        <tr>
                            <td><code>set -x</code></td>
                            <td>Debug mode</td>
                            <td>Affiche chaque commande avant ex√©cution</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# Mode strict (recommand√© pour tous les scripts de production)
set -euo pipefail

# Explication :
# -e : Exit imm√©diatement si une commande retourne un code non-zero
# -u : Traite les variables non d√©finies comme des erreurs
# -o pipefail : Le code de retour d'un pipeline est celui de la derni√®re commande qui a √©chou√©

# Exemple sans set -e
echo "Starting script"
false  # Cette commande √©choue
echo "This will still execute"  # S'ex√©cute quand m√™me

# Exemple avec set -e
set -e
echo "Starting script"
false  # Cette commande √©choue
echo "This will NOT execute"  # Ne s'ex√©cute jamais

# Exemple avec set -u
set -u
echo $undefined_variable  # Erreur : variable non d√©finie

# Exemple avec set -o pipefail
set -o pipefail
cat non_existent_file | grep "pattern"  # Tout le pipeline √©choue

# D√©sactiver temporairement
set +e
command_that_might_fail || true
set -e

# Script complet avec gestion d'erreurs
#!/bin/bash
set -euo pipefail

# Fonction de nettoyage en cas d'erreur
cleanup() {
    echo "Error occurred. Cleaning up..."
    rm -f temp_files*
}

# Appeler cleanup si erreur
trap cleanup ERR

echo "Processing data..."
# Vos commandes ici</code></pre>
                </div>

                <h3>Codes de retour et gestion d'erreurs</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/bin/bash

# Codes de retour standards
# 0 = succ√®s
# 1-255 = erreur

# V√©rifier le code de retour
ls /existing_directory
echo "Return code: $?"  # 0 (succ√®s)

ls /non_existent_directory
echo "Return code: $?"  # 2 (erreur)

# Utiliser le code de retour dans une condition
if ls /tmp > /dev/null 2>&1; then
    echo "Directory exists"
else
    echo "Directory does not exist"
fi

# Retourner un code d'erreur depuis un script
exit 0   # Succ√®s
exit 1   # Erreur g√©n√©rique
exit 2   # Erreur d'utilisation
exit 127 # Commande non trouv√©e

# Exemple complet avec gestion d'erreurs
#!/bin/bash
set -euo pipefail

INPUT_FILE=$1

# V√©rifier que le fichier existe
if [ ! -f "$INPUT_FILE" ]; then
    echo "Error: File '$INPUT_FILE' not found" >&2
    exit 1
fi

# V√©rifier que le fichier n'est pas vide
if [ ! -s "$INPUT_FILE" ]; then
    echo "Error: File '$INPUT_FILE' is empty" >&2
    exit 2
fi

# Traiter le fichier
if ! process_file "$INPUT_FILE"; then
    echo "Error: Failed to process file" >&2
    exit 3
fi

echo "Success"
exit 0

# Utiliser || et && pour g√©rer les erreurs
command1 && command2  # command2 s'ex√©cute SI command1 r√©ussit
command1 || command2  # command2 s'ex√©cute SI command1 √©choue

# Exemples pratiques
mkdir /tmp/mydir || { echo "Failed to create directory"; exit 1; }
cd /tmp/mydir && echo "Directory changed successfully"

# Forcer le succ√®s (ignorer les erreurs)
command_that_might_fail || true

# Capturer le code de retour
command
return_code=$?
if [ $return_code -ne 0 ]; then
    echo "Command failed with code $return_code"
fi</code></pre>
                </div>

                <h3>Debugging de scripts</h3>

                <table>
                    <thead>
                        <tr>
                            <th>M√©thode</th>
                            <th>Description</th>
                            <th>Usage</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>bash -x script.sh</code></td>
                            <td>Ex√©cuter en mode debug</td>
                            <td>Affiche chaque commande</td>
                        </tr>
                        <tr>
                            <td><code>set -x</code></td>
                            <td>Activer le debug dans le script</td>
                            <td>Trace l'ex√©cution</td>
                        </tr>
                        <tr>
                            <td><code>set +x</code></td>
                            <td>D√©sactiver le debug</td>
                            <td>Arr√™ter la trace</td>
                        </tr>
                        <tr>
                            <td><code>echo "DEBUG: ..."</code></td>
                            <td>Messages de debug manuels</td>
                            <td>Points de contr√¥le</td>
                        </tr>
                        <tr>
                            <td><code>bash -n script.sh</code></td>
                            <td>V√©rifier la syntaxe</td>
                            <td>Sans ex√©cuter</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash"># M√©thode 1 : Ex√©cuter avec -x
bash -x script.sh

# Output avec traces :
# + echo 'Starting script'
# Starting script
# + date
# Mon Jan 15 10:30:00 UTC 2024

# M√©thode 2 : set -x dans le script
#!/bin/bash
set -x  # Activer le debug

echo "Processing data"
ls /tmp
date

set +x  # D√©sactiver le debug
echo "Debug off"

# M√©thode 3 : Debug conditionnel
#!/bin/bash

DEBUG=${DEBUG:-0}

debug() {
    if [ $DEBUG -eq 1 ]; then
        echo "DEBUG: $*" >&2
    fi
}

debug "Starting processing"
process_data
debug "Processing complete"

# Utilisation : DEBUG=1 ./script.sh

# M√©thode 4 : V√©rifier la syntaxe sans ex√©cuter
bash -n script.sh

# M√©thode 5 : Fonction de logging
#!/bin/bash

log() {
    local level=$1
    shift
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [$level] $*" >&2
}

log INFO "Script started"
log DEBUG "Processing file: $filename"
log ERROR "File not found"
log WARN "Disk space low"

# M√©thode 6 : Tracer seulement une partie
#!/bin/bash

echo "Normal execution"

set -x
# Section √† debugger
complex_operation
another_operation
set +x

echo "Back to normal"

# M√©thode 7 : Sauvegarder les traces dans un fichier
#!/bin/bash
exec 2> debug.log  # Rediriger stderr vers un fichier
set -x

# Toutes les traces iront dans debug.log
command1
command2

# M√©thode 8 : Variables de d√©bogage
#!/bin/bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

echo "Script: $SCRIPT_NAME"
echo "Directory: $SCRIPT_DIR"
echo "Arguments: $@"
echo "Number of args: $#"</code></pre>
                </div>

                <h3>Exemple complet : Script de traitement de donn√©es</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/usr/bin/env bash
#
# Script: process_sales_data.sh
# Description: Traite les fichiers de ventes et g√©n√®re un rapport
# Usage: ./process_sales_data.sh <input_csv> <output_dir>
#

set -euo pipefail

# Variables globales
readonly SCRIPT_NAME=$(basename "$0")
readonly TIMESTAMP=$(date +%Y%m%d_%H%M%S)
readonly LOG_FILE="process_${TIMESTAMP}.log"

# Couleurs pour les messages
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

# Fonctions de logging
log_info() {
    echo -e "${GREEN}[INFO]${NC} $*" | tee -a "$LOG_FILE"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" | tee -a "$LOG_FILE"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" | tee -a "$LOG_FILE" >&2
}

# Fonction d'aide
usage() {
    cat << EOF
Usage: $SCRIPT_NAME <input_csv> <output_dir>

Process sales data and generate reports.

Arguments:
    input_csv   Path to input CSV file
    output_dir  Directory for output files

Example:
    $SCRIPT_NAME sales_2024.csv ./reports
EOF
    exit 1
}

# V√©rification des arguments
if [ $# -ne 2 ]; then
    log_error "Invalid number of arguments"
    usage
fi

INPUT_FILE=$1
OUTPUT_DIR=$2

# Validation des entr√©es
log_info "Validating inputs..."

if [ ! -f "$INPUT_FILE" ]; then
    log_error "Input file not found: $INPUT_FILE"
    exit 1
fi

if [ ! -s "$INPUT_FILE" ]; then
    log_error "Input file is empty: $INPUT_FILE"
    exit 2
fi

# Cr√©er le r√©pertoire de sortie
mkdir -p "$OUTPUT_DIR"

# Fonction de nettoyage en cas d'erreur
cleanup() {
    log_warn "Cleaning up temporary files..."
    rm -f "${OUTPUT_DIR}"/temp_*
}

trap cleanup EXIT ERR

# Traitement principal
log_info "Starting data processing..."
log_info "Input: $INPUT_FILE"
log_info "Output directory: $OUTPUT_DIR"

# Compter les lignes
total_lines=$(wc -l < "$INPUT_FILE")
log_info "Total lines: $total_lines"

# G√©n√©rer le rapport de r√©sum√©
report_file="${OUTPUT_DIR}/summary_${TIMESTAMP}.txt"
log_info "Generating summary report..."

{
    echo "Sales Data Summary Report"
    echo "========================="
    echo "Generated: $(date)"
    echo "Input file: $INPUT_FILE"
    echo ""
    echo "Statistics:"
    echo "- Total records: $((total_lines - 1))"
    echo ""
    echo "Top 10 products by sales:"
    tail -n +2 "$INPUT_FILE" | \
        awk -F',' '{print $2}' | \
        sort | uniq -c | sort -rn | head -10
} > "$report_file"

log_info "Summary report saved to: $report_file"

# Filtrer les ventes importantes (>1000)
high_value_file="${OUTPUT_DIR}/high_value_${TIMESTAMP}.csv"
log_info "Filtering high-value sales..."

head -1 "$INPUT_FILE" > "$high_value_file"
awk -F',' 'NR>1 && $4 > 1000' "$INPUT_FILE" >> "$high_value_file"

high_value_count=$(( $(wc -l < "$high_value_file") - 1 ))
log_info "Found $high_value_count high-value sales"

# Calculer le total
total_sales=$(awk -F',' 'NR>1 {sum += $4} END {print sum}' "$INPUT_FILE")
log_info "Total sales amount: $total_sales"

# Succ√®s
log_info "Processing completed successfully!"
log_info "Output files:"
log_info "  - $report_file"
log_info "  - $high_value_file"
log_info "Log file: $LOG_FILE"

exit 0</code></pre>
                </div>

                <h3>Template de script robuste</h3>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-dot red"></span>
                        <span class="code-dot yellow"></span>
                        <span class="code-dot green"></span>
                    </div>
                    <pre><code class="language-bash">#!/usr/bin/env bash
#
# Script: template.sh
# Description: Template pour scripts robustes
# Author: Your Name
# Date: 2024-01-15
#

# Mode strict
set -euo pipefail

# Variables globales (constantes en majuscules)
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
readonly TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Configuration
DEBUG=${DEBUG:-0}
VERBOSE=${VERBOSE:-0}

# Fonctions utilitaires
die() {
    echo "ERROR: $*" >&2
    exit 1
}

log_debug() {
    [ $DEBUG -eq 1 ] && echo "DEBUG: $*" >&2
}

log_verbose() {
    [ $VERBOSE -eq 1 ] && echo "INFO: $*" >&2
}

usage() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS] <arguments>

Description of what the script does.

OPTIONS:
    -h, --help      Show this help message
    -v, --verbose   Verbose output
    -d, --debug     Debug mode

ARGUMENTS:
    arg1            Description of arg1
    arg2            Description of arg2

EXAMPLES:
    $SCRIPT_NAME input.csv output.csv
    DEBUG=1 $SCRIPT_NAME input.csv output.csv
EOF
    exit 0
}

# Nettoyage √† la sortie
cleanup() {
    log_debug "Cleanup function called"
    # Ajoutez votre code de nettoyage ici
}

trap cleanup EXIT

# Parser les options
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        -d|--debug)
            DEBUG=1
            shift
            ;;
        -*)
            die "Unknown option: $1"
            ;;
        *)
            break
            ;;
    esac
done

# Validation des arguments
[ $# -lt 1 ] && usage

# Votre logique principale ici
log_verbose "Script started"
log_debug "Arguments: $*"

# ... votre code ...

log_verbose "Script completed successfully"
exit 0</code></pre>
                </div>

                <h3>Exercices pratiques</h3>

                <div class="exercise">
                    <h4>üéØ Exercice 1 : Script basique</h4>
                    <p>Cr√©ez un script <code>backup.sh</code> qui :</p>
                    <ol>
                        <li>Prend un r√©pertoire en argument</li>
                        <li>V√©rifie que le r√©pertoire existe</li>
                        <li>Cr√©e une archive tar.gz avec la date dans le nom</li>
                        <li>Affiche un message de succ√®s avec la taille de l'archive</li>
                    </ol>

                    <details class="exercise-solution">
                        <summary>üí° Voir la solution</summary>
                        <div class="code-container">
                            <pre><code class="language-bash">#!/bin/bash
set -euo pipefail

# V√©rifier les arguments
if [ $# -ne 1 ]; then
    echo "Usage: $0 <directory>"
    exit 1
fi

DIR=$1

# V√©rifier que le r√©pertoire existe
if [ ! -d "$DIR" ]; then
    echo "Error: Directory '$DIR' not found"
    exit 1
fi

# Cr√©er l'archive
BACKUP_NAME="backup_$(basename "$DIR")_$(date +%Y%m%d_%H%M%S).tar.gz"
tar -czf "$BACKUP_NAME" "$DIR"

# Afficher le r√©sultat
SIZE=$(du -h "$BACKUP_NAME" | cut -f1)
echo "Backup created successfully: $BACKUP_NAME"
echo "Size: $SIZE"</code></pre>
                        </div>
                    </details>
                </div>

                <div class="exercise">
                    <h4>üéØ Exercice 2 : Script avec options</h4>
                    <p>Cr√©ez un script <code>analyze.sh</code> qui :</p>
                    <ol>
                        <li>Accepte un fichier CSV en argument</li>
                        <li>Option -c : compter les lignes</li>
                        <li>Option -h : afficher le header</li>
                        <li>Option -s : afficher les statistiques (nombre de colonnes)</li>
                        <li>Sans option : afficher les 10 premi√®res lignes</li>
                    </ol>

                    <details class="exercise-solution">
                        <summary>üí° Voir la solution</summary>
                        <div class="code-container">
                            <pre><code class="language-bash">#!/bin/bash
set -euo pipefail

usage() {
    echo "Usage: $0 [-c|-h|-s] <file.csv>"
    echo "  -c  Count lines"
    echo "  -h  Show header"
    echo "  -s  Show statistics"
    exit 1
}

# Parser les options
while getopts "chs" opt; do
    case $opt in
        c) MODE="count" ;;
        h) MODE="header" ;;
        s) MODE="stats" ;;
        *) usage ;;
    esac
done

shift $((OPTIND-1))

# V√©rifier le fichier
[ $# -ne 1 ] && usage
FILE=$1

[ ! -f "$FILE" ] && { echo "Error: File not found"; exit 1; }

# Ex√©cuter selon le mode
case ${MODE:-preview} in
    count)
        wc -l < "$FILE"
        ;;
    header)
        head -1 "$FILE"
        ;;
    stats)
        echo "Lines: $(wc -l < "$FILE")"
        echo "Columns: $(head -1 "$FILE" | awk -F',' '{print NF}')"
        ;;
    preview)
        head -10 "$FILE"
        ;;
esac</code></pre>
                        </div>
                    </details>
                </div>

                <div class="alert alert-success">
                    <h4>üí° Points cl√©s √† retenir</h4>
                    <ul>
                        <li><code>#!/usr/bin/env bash</code> : shebang portable</li>
                        <li><code>set -euo pipefail</code> : mode strict obligatoire</li>
                        <li><code>$1, $2, $@, $#</code> : gestion des arguments</li>
                        <li><code>read</code> : lire les entr√©es utilisateur</li>
                        <li><code>exit 0/1</code> : codes de retour</li>
                        <li><code>bash -x</code> : debug mode</li>
                        <li>Toujours valider les entr√©es et g√©rer les erreurs</li>
                        <li>Utiliser des fonctions de logging</li>
                    </ul>
                </div>
            </section>

            <div class="alert alert-success">
                <h4>‚úÖ Partie 4 termin√©e !</h4>
                <p>
                    Vous savez maintenant cr√©er des scripts shell robustes et automatis√©s. Passez √† la Partie 5
                    pour apprendre les structures de contr√¥le (conditions, boucles).
                </p>
                <p style="margin-top: 20px;">
                    <a href="partie5.html"
                        style="display: inline-block; padding: 12px 25px; background: #0066cc; color: white; text-decoration: none; border-radius: 8px; font-weight: 600;">
                        Partie 5 : Structures de Contr√¥le et Boucles ‚Üí
                    </a>
                </p>
            </div>
        </div>

        <footer>
            <p>Formation Bash/Zsh pour Data Engineering - 2024</p>
            <p><a href="../index.html">‚Üê Retour √† l'accueil</a></p>
        </footer>
    </div>

    <!-- Prism.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</body>

</html>
